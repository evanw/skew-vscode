@import {
  def require(name string) dynamic
  def clearTimeout(timeout int)
  def setTimeout(callback fn(), ms int) int
  var process dynamic
}

var server = require("vscode-languageserver")
var skew = require("skew").create()
var path = require("path")
var fs = require("fs")

@entry
def main {
  var connection = server.createConnection(
    server.IPCMessageReader.new(process),
    server.IPCMessageWriter.new(process))

  # The builder handles scheduling asynchronous builds
  var builder = Builder.new(connection)

  # Listen to open documents
  var openDocuments = server.TextDocuments.new()
  builder.openDocuments = openDocuments
  openDocuments.listen(connection)
  openDocuments.onDidChangeContent(change => {
    builder.buildLater
  })

  # Grab the workspace when the connection opens
  connection.onInitialize(params => {
    builder.workspaceRoot = params.rootPath
    builder.buildLater
    return {
      "capabilities": {
        "textDocumentSync": openDocuments.syncKind,
        "hoverProvider": true,
        "definitionProvider": true,
      },
    }
  })

  # Show tooltips on hover
  connection.onHover(request => {
    var tooltip dynamic = null
    reportErrors(connection, => {
      tooltip = computeTooltip(request)
    })
    return tooltip
  })

  # Support the "go to definition" feature
  connection.onDefinition(request => {
    var location dynamic = null
    reportErrors(connection, => {
      location = computeDefinitionLocation(request)
    })
    return location
  })

  # Listen to file system changes for *.sk files
  connection.onDidChangeWatchedFiles(change => {
    builder.buildLater
  })

  connection.listen()
}

def computeTooltip(request dynamic) dynamic {
  var absolute = server.Files.uriToFilePath(request.uri)
  var result = skew.tooltipQuery({
    "source": absolute,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.tooltip != null {
    return {
      "contents": {
        "language": "skew",
        "value": result.tooltip,
      },
      "range": convertRange(result.range),
    }
  }
  return null
}

def computeDefinitionLocation(request dynamic) dynamic {
  var absolute = server.Files.uriToFilePath(request.uri)
  var result = skew.definitionQuery({
    "source": absolute,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.definition != null {
    return {
      "uri": pathToURI(result.definition.source),
      "range": convertRange(result.definition),
    }
  }
  return null
}

class Builder {
  var connection dynamic
  var workspaceRoot string = null
  var openDocuments dynamic = null
  var timeout = -1

  def buildLater {
    clearTimeout(timeout)
    timeout = setTimeout(=> {
      reportErrors(connection, => {
        sendDiagnostics(connection, build(workspaceRoot, openDocuments))
      })
    }, 100)
  }
}

def reportErrors(connection dynamic, callback fn()) {
  try {
    callback()
  } catch e dynamic {
    var message = (e && e.stack ? e.stack : e) + ""
    connection.console.error("skew: \(message)")
    connection.window.showErrorMessage("skew: \(message)")
  }
}

def findAllFiles(root string, filter fn(string) bool) List<string> {
  var files List<string> = []
  var folders = [root]

  while !folders.isEmpty {
    var folder = folders.takeLast
    var entries List<string> = fs.readdirSync(folder)

    for entry in entries {
      var absolute = path.join(folder, entry)

      if fs.statSync(absolute).isDirectory() {
        folders.append(absolute)
      }

      else if filter(entry) {
        files.append(absolute)
      }
    }
  }

  return files
}

def build(workspaceRoot dynamic, openDocuments dynamic) List<dynamic> {
  var files = findAllFiles(workspaceRoot, name => name.endsWith(".sk"))
  var inputs List<dynamic> = []

  # Read file contents but check for content in open documents first
  for absolute in files {
    var document = openDocuments.get(pathToURI(absolute))
    inputs.append({
      "name": absolute,
      "contents": document ? document.getText() : fs.readFileSync(absolute, "utf8"),
    } as dynamic)
  }

  # Pass the inputs to the compiler for a build
  var result = skew.compile({
    "target": "js",
    "inputs": inputs,
    "stopAfterResolve": true,
  })

  return result.log.diagnostics
}

def convertRange(range dynamic) dynamic {
  return {
    "start": {
      "line": range.start.line,
      "character": range.start.column
    },
    "end": {
      "line": range.end.line,
      "character": range.end.column
    },
  }
}

def sendDiagnostics(connection dynamic, diagnostics List<dynamic>) {
  var map StringMap<List<dynamic>> = {}

  for diagnostic in diagnostics {
    var absolute = diagnostic.range.source
    var group = map.get(absolute, null)

    if group == null {
      group = []
      map[absolute] = group
    }

    group.append({
      "severity": diagnostic.kind == "error" ? server.DiagnosticSeverity.Error : server.DiagnosticSeverity.Warning,
      "range": convertRange(diagnostic.range),
      "message": diagnostic.text,
    } as dynamic)
  }

  map.each((absolute, fileDiagnostics) => {
    connection.sendDiagnostics({
      "uri": pathToURI(absolute),
      "diagnostics": fileDiagnostics,
    })
  })
}

def pathToURI(absolute string) string {
  return "file://" + "/".join(absolute
    .replaceAll("\\", "/").split("/")
    .map<string>(dynamic.encodeURIComponent))
}
