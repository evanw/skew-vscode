enum Build {
  NONE
  EXTENSION
  SERVER
}

const BUILD Build = .NONE

@import {
  def require(name string) dynamic
  def clearTimeout(timeout int)
  def setTimeout(callback fn(), ms int) int
  var process dynamic
  var exports dynamic
}

var fs = require("fs")
var path = require("path")
var vscode = require("vscode")
var client = require("vscode-languageclient")
var server = require("vscode-languageserver")

@entry if BUILD == .EXTENSION
def extensionMain {
  exports.activate = context => {
    var serverModule = context.asAbsolutePath(path.join("out", "server.js"))

    var serverOptions dynamic = {
      "run": { "module": serverModule, "transport": client.TransportKind.ipc },
      "debug": { "module": serverModule, "transport": client.TransportKind.ipc },
    }

    var clientOptions dynamic = {
      "documentSelector": ["skew"],
      "synchronize": {
        "fileEvents": vscode.workspace.createFileSystemWatcher("**/*.sk"),
      },
    }

    var server = client.LanguageClient.new("Skew", serverOptions, clientOptions)
    context.subscriptions.push(server.start())

    context.subscriptions.push(vscode.languages.registerCodeActionsProvider("skew", {
      "provideCodeActions": (document, range, context) => {
        var diagnostic = context.diagnostics[0]
        var message string = diagnostic.message
        var commands List<dynamic> = []
        var arguments = [document, diagnostic.range]

        if message == "Unnecessary parentheses" {
          commands.append({
            "title": "Remove unnecessary parentheses",
            "command": "skew.removeParentheses",
            "arguments": arguments,
          } as dynamic)
        }

        else if message.startsWith("Unnecessary cast from type") {
          commands.append({
            "title": "Remove unnecessary cast",
            "command": "skew.removeCast",
            "arguments": arguments,
          } as dynamic)
        }

        else if message == "Number interpreted as decimal (use the prefix \"0o\" for octal numbers)" {
          commands.append({
            "title": "Remove leading zeros to avoid confusion",
            "command": "skew.removeLeadingZeros",
            "arguments": arguments,
          } as dynamic)

          commands.append({
            "title": "Add \"0o\" to interpret as octal",
            "command": "skew.addOctalPrefix",
            "arguments": arguments,
          } as dynamic)
        }

        return commands
      },
    }))

    context.subscriptions.push(vscode.commands.registerCommand("skew.removeParentheses", (document, range) => {
      var text string = document.getText(range)
      if text.startsWith("(") && text.endsWith(")") {
        text = text.slice(1, text.count - 1)
        var edit = vscode.WorkspaceEdit.new()
        edit.replace(document.uri, range, text)
        vscode.workspace.applyEdit(edit)
      }
    }))

    context.subscriptions.push(vscode.commands.registerCommand("skew.removeCast", (document, range) => {
      var text string = document.getText(range)
      if text.startsWith("as ") {
        var line = document.lineAt(range.start).text
        var column = line.slice(0, range.start.character).trimRight().length
        range = vscode.Range.new(
          range.start.line, column,
          range.end.line, range.end.character)
        var edit = vscode.WorkspaceEdit.new()
        edit.replace(document.uri, range, "")
        vscode.workspace.applyEdit(edit)
      }
    }))

    context.subscriptions.push(vscode.commands.registerCommand("skew.removeLeadingZeros", (document, range) => {
      var text string = document.getText(range)
      var value double = +(text as dynamic)
      if text.startsWith("0") && value == value {
        while text.startsWith("0") {
          text = text.slice(1)
        }
        var edit = vscode.WorkspaceEdit.new()
        edit.replace(document.uri, range, text)
        vscode.workspace.applyEdit(edit)
      }
    }))

    context.subscriptions.push(vscode.commands.registerCommand("skew.addOctalPrefix", (document, range) => {
      var text string = document.getText(range)
      var value double = +(text as dynamic)
      if value == value {
        while text.startsWith("0") {
          text = text.slice(1)
        }
        var edit = vscode.WorkspaceEdit.new()
        edit.replace(document.uri, range, "0o" + text)
        vscode.workspace.applyEdit(edit)
      }
    }))
  }
}

@entry if BUILD == .SERVER
def serverMain {
  var skew = require("skew").create()
  var connection = server.createConnection(
    server.IPCMessageReader.new(process),
    server.IPCMessageWriter.new(process))

  # The builder handles scheduling asynchronous builds
  var builder = Builder.new(skew, connection)

  # Listen to open documents
  var openDocuments = server.TextDocuments.new()
  builder.openDocuments = openDocuments
  openDocuments.listen(connection)
  openDocuments.onDidChangeContent(change => {
    builder.buildLater
  })

  # Grab the workspace when the connection opens
  connection.onInitialize(params => {
    builder.workspaceRoot = params.rootPath
    builder.buildLater
    return {
      "capabilities": {
        "textDocumentSync": openDocuments.syncKind,
        "hoverProvider": true,
        "renameProvider": true,
        "definitionProvider": true,
        "documentSymbolProvider": true,
      },
    }
  })

  # Show tooltips on hover
  connection.onHover(request => {
    var tooltip dynamic = null
    reportErrors(connection, => {
      tooltip = computeTooltip(skew, request)
    })
    return tooltip
  })

  # Support the "go to definition" feature
  connection.onDefinition(request => {
    var location dynamic = null
    reportErrors(connection, => {
      location = computeDefinitionLocation(skew, request)
    })
    return location
  })

  # Support the "go to symbol" feature
  connection.onDocumentSymbol(request => {
    var info List<dynamic> = null
    reportErrors(connection, => {
      info = computeDocumentSymbols(skew, request)
    })
    return info
  })

  # Support the "rename symbol" feature
  connection.onRenameRequest(request => {
    var edits dynamic = null
    reportErrors(connection, => {
      edits = computeRenameEdits(skew, request)
    })
    return edits
  })

  # Listen to file system changes for *.sk files
  connection.onDidChangeWatchedFiles(change => {
    builder.buildLater
  })

  connection.listen()
}

def computeTooltip(skew dynamic, request dynamic) dynamic {
  var absolute = server.Files.uriToFilePath(request.uri)
  var result = skew.tooltipQuery({
    "source": absolute,
    "line": request.position.line,
    "column": request.position.character,

    # Visual Studio Code already includes diagnostics and including
    # them in the results causes each diagnostic to be shown twice
    "ignoreDiagnostics": true,
  })
  if result.tooltip != null {
    return {
      "contents": {
        "language": "skew",
        "value": result.tooltip,
      },
      "range": convertRange(result.range),
    }
  }
  return null
}

def computeDefinitionLocation(skew dynamic, request dynamic) dynamic {
  var absolute = server.Files.uriToFilePath(request.uri)
  var result = skew.definitionQuery({
    "source": absolute,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.definition != null {
    return {
      "uri": pathToURI(result.definition.source),
      "range": convertRange(result.definition),
    }
  }
  return null
}

enum VisualStudioCode.SymbolKind {
  NONE
  FILE
  MODULE
  NAMESPACE
  PACKAGE
  CLASS
  METHOD
  PROPERTY
  FIELD
  CONSTRUCTOR
  ENUM
  INTERFACE
  FUNCTION
  VARIABLE
  CONSTANT
  STRING
  NUMBER
  BOOLEAN
  ARRAY
}

const symbolKindMap StringMap<VisualStudioCode.SymbolKind> = {
  "OBJECT_CLASS": .CLASS,
  "OBJECT_ENUM": .ENUM,
  "OBJECT_INTERFACE": .INTERFACE,
  "OBJECT_NAMESPACE": .NAMESPACE,
  "OBJECT_WRAPPED": .CLASS,

  "FUNCTION_ANNOTATION": .FUNCTION,
  "FUNCTION_CONSTRUCTOR": .CONSTRUCTOR,
  "FUNCTION_GLOBAL": .FUNCTION,
  "FUNCTION_INSTANCE": .METHOD,

  "VARIABLE_ENUM": .VARIABLE,
  "VARIABLE_GLOBAL": .VARIABLE,
  "VARIABLE_INSTANCE": .FIELD,
}

def computeDocumentSymbols(skew dynamic, request dynamic) List<dynamic> {
  var absolute = server.Files.uriToFilePath(request.uri)
  var result = skew.symbolsQuery({
    "source": absolute,
  })
  if result.symbols == null {
    return null
  }
  var symbols List<dynamic> = []
  for symbol in result.symbols as List<dynamic> {
    var kind = symbolKindMap.get(symbol.kind, .NONE)
    if kind != .NONE {
      symbols.append({
        "name": symbol.name,
        "kind": kind,
        "location": {
          "uri": request.uri,
          "range": convertRange(symbol.range),
        },
        "containerName": symbol.parent,
      } as dynamic)
    }
  }
  return symbols
}

def computeRenameEdits(skew dynamic, request dynamic) dynamic {
  var absolute = server.Files.uriToFilePath(request.textDocument.uri)
  var result = skew.renameQuery({
    "source": absolute,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.ranges == null {
    return null
  }
  var map StringMap<List<dynamic>> = {}
  for range in result.ranges as List<dynamic> {
    var uri = pathToURI(range.source)
    var changes = map.get(uri, null)
    if changes == null {
      map[uri] = changes = []
    }
    changes.append({
      "range": convertRange(range),
      "newText": request.newName,
    } as dynamic)
  }
  return {
    "changes": map,
  }
}

class Builder {
  var skew dynamic
  var connection dynamic
  var workspaceRoot string = null
  var openDocuments dynamic = null
  var timeout = -1

  def buildLater {
    clearTimeout(timeout)
    timeout = setTimeout(=> {
      reportErrors(connection, => {
        var diagnostics = build(skew, workspaceRoot, openDocuments)
        sendDiagnostics(openDocuments, diagnostics, connection)
      })
    }, 100)
  }
}

def reportErrors(connection dynamic, callback fn()) {
  try {
    callback()
  } catch e dynamic {
    var message = (e && e.stack ? e.stack : e) + ""
    connection.console.error("skew: \(message)")
    connection.window.showErrorMessage("skew: \(message)")
  }
}

def findAllFiles(root string, filter fn(string) bool) List<string> {
  var files List<string> = []
  var folders = [root]

  while !folders.isEmpty {
    var folder = folders.takeLast
    var entries List<string> = fs.readdirSync(folder)

    for entry in entries {
      var absolute = path.join(folder, entry)

      if fs.statSync(absolute).isDirectory() {
        folders.append(absolute)
      }

      else if filter(entry) {
        files.append(absolute)
      }
    }
  }

  return files
}

def build(skew dynamic, workspaceRoot dynamic, openDocuments dynamic) List<dynamic> {
  var files = findAllFiles(workspaceRoot, name => name.endsWith(".sk"))
  var inputs List<dynamic> = []

  # Read file contents but check for content in open documents first
  for absolute in files {
    var document = openDocuments.get(pathToURI(absolute))
    inputs.append({
      "name": absolute,
      "contents": document ? document.getText() : fs.readFileSync(absolute, "utf8"),
    } as dynamic)
  }

  # Pass the inputs to the compiler for a build
  var result = skew.compile({
    "target": "js",
    "inputs": inputs,
    "stopAfterResolve": true,
  })

  return result.log.diagnostics
}

def convertRange(range dynamic) dynamic {
  return {
    "start": {
      "line": range.start.line,
      "character": range.start.column
    },
    "end": {
      "line": range.end.line,
      "character": range.end.column
    },
  }
}

def sendDiagnostics(openDocuments dynamic, diagnostics List<dynamic>, connection dynamic) {
  var allDocuments List<dynamic> = openDocuments.all()
  var map StringMap<List<dynamic>> = {}

  for diagnostic in diagnostics {
    var absolute = diagnostic.range.source
    var group = map.get(absolute, null)

    if group == null {
      group = []
      map[absolute] = group
    }

    group.append({
      "severity": diagnostic.kind == "error" ? server.DiagnosticSeverity.Error : server.DiagnosticSeverity.Warning,
      "range": convertRange(diagnostic.range),
      "message": diagnostic.text,
    } as dynamic)
  }

  for textDocument in allDocuments {
    var absolute = server.Files.uriToFilePath(textDocument.uri)
    connection.sendDiagnostics({
      "uri": textDocument.uri,
      "diagnostics": map.get(absolute, []),
    })
  }
}

def pathToURI(absolute string) string {
  return "file://" + "/".join(absolute
    .replaceAll("\\", "/").split("/")
    .map<string>(dynamic.encodeURIComponent))
}
