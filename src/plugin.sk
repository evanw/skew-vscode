enum Build {
  NONE
  EXTENSION
  SERVER
}

const BUILD Build = .NONE

@import {
  def require(name string) dynamic
  def clearTimeout(timeout int)
  def setTimeout(callback fn(), ms int) int
  var process dynamic
  var exports dynamic

  namespace JSON {
    def parse(data string) dynamic
    def stringify(data dynamic) string
  }
}

var fs = require("fs")
var path = require("path")
var vscode = require("vscode")
var client = require("vscode-languageclient")
var server = require("vscode-languageserver")

@entry if BUILD == .EXTENSION
def extensionMain {
  exports.activate = context => {
    var serverModule = context.asAbsolutePath(path.join("out", "server.js"))

    var serverOptions dynamic = {
      "run": { "module": serverModule, "transport": client.TransportKind.ipc },
      "debug": { "module": serverModule, "transport": client.TransportKind.ipc },
    }

    var clientOptions dynamic = {
      "documentSelector": ["skew"],
      "synchronize": {
        "fileEvents": vscode.workspace.createFileSystemWatcher("**/*.sk"),
      },
    }

    var server = client.LanguageClient.new("Skew", serverOptions, clientOptions)
    context.subscriptions.push(server.start())

    context.subscriptions.push(vscode.languages.registerCodeActionsProvider("skew", {
      "provideCodeActions": (document, range, context) => {
        var commands List<dynamic> = []
        reportErrorsFromExtension(=> {
          # The only way to transport extra data is by abusing the "code" field
          var diagnostic = context.diagnostics[0]
          var fixes List<dynamic>
          try {
            fixes = JSON.parse(diagnostic.code)
          } catch {
            return
          }

          # Convert each fix into a code action
          for fix in fixes {
            commands.append({
              "title": fix.description,
              "command": "skew.applyFix",
              "arguments": [document.uri.toString(), fix.range, fix.expected, fix.replacement],
            } as dynamic)
          }
        })
        return commands
      },
    }))

    context.subscriptions.push(vscode.commands.registerCommand("skew.applyFix", (uri, range, expected, replacement) => {
      reportErrorsFromExtension(=> {
        var converted = convertRangeFromExtension(range)
        for document in vscode.workspace.textDocuments as List<dynamic> {

          # Make sure the contents of the document are still what they should be
          if document.uri.toString() == uri && document.getText(converted) == expected {
            var edit = vscode.WorkspaceEdit.new()
            edit.replace(document.uri, converted, replacement)
            vscode.workspace.applyEdit(edit)
            break
          }
        }
      })
    }))
  }
}

@entry if BUILD == .SERVER
def serverMain {
  var skew = require("skew").create()
  var connection = server.createConnection(
    server.IPCMessageReader.new(process),
    server.IPCMessageWriter.new(process))

  # The builder handles scheduling asynchronous builds
  var builder = Builder.new(skew, connection)

  # Listen to open documents
  var openDocuments = server.TextDocuments.new()
  builder.openDocuments = openDocuments
  openDocuments.listen(connection)
  openDocuments.onDidChangeContent(change => {
    builder.buildLater
  })

  # Grab the workspace when the connection opens
  connection.onInitialize(params => {
    builder.workspaceRoot = params.rootPath ? params.rootPath : null
    builder.buildLater
    return {
      "capabilities": {
        "textDocumentSync": openDocuments.syncKind,
        "hoverProvider": true,
        "renameProvider": true,
        "definitionProvider": true,
        "documentSymbolProvider": true,
        "completionProvider": {
          "resolveProvider": true,
        },
      },
    }
  })

  # Show tooltips on hover
  connection.onHover(request => {
    var tooltip dynamic = null
    reportErrorsFromServer(connection, => {
      tooltip = computeTooltip(skew, request)
    })
    return tooltip
  })

  # Support the "go to definition" feature
  connection.onDefinition(request => {
    var location dynamic = null
    reportErrorsFromServer(connection, => {
      location = computeDefinitionLocation(skew, request)
    })
    return location
  })

  # Support the "go to symbol" feature
  connection.onDocumentSymbol(request => {
    var info List<dynamic> = null
    reportErrorsFromServer(connection, => {
      info = computeDocumentSymbols(skew, request)
    })
    return info
  })

  # Support the "rename symbol" feature
  connection.onRenameRequest(request => {
    var edits dynamic = null
    reportErrorsFromServer(connection, => {
      edits = computeRenameEdits(skew, request)
    })
    return edits
  })

  # Support the code completion feature
  connection.onCompletion(request => {
    var list List<dynamic> = null
    reportErrorsFromServer(connection, => {
      list = computeCompletions(skew, request, builder)
    })
    return list
  })
  connection.onCompletionResolve(request => {
    var details dynamic = null
    reportErrorsFromServer(connection, => {
      details = computeCompletionDetails(skew, request, connection)
    })
    return details
  })

  # Listen to file system changes for *.sk files
  connection.onDidChangeWatchedFiles(change => {
    builder.buildLater
  })

  connection.listen()
}

def computeTooltip(skew dynamic, request dynamic) dynamic {
  var result = skew.tooltipQuery({
    "source": request.uri,
    "line": request.position.line,
    "column": request.position.character,

    # Visual Studio Code already includes diagnostics and including
    # them in the results causes each diagnostic to be shown twice
    "ignoreDiagnostics": true,
  })
  if result.tooltip != null {
    return {
      "contents": {
        "language": "skew",
        "value": result.tooltip,
      },
      "range": convertRangeFromServer(result.range),
    }
  }
  return null
}

def computeDefinitionLocation(skew dynamic, request dynamic) dynamic {
  var result = skew.definitionQuery({
    "source": request.uri,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.definition != null {
    return {
      "uri": result.definition.source,
      "range": convertRangeFromServer(result.definition),
    }
  }
  return null
}

enum VisualStudioCode.SymbolKind {
  NONE
  FILE
  MODULE
  NAMESPACE
  PACKAGE
  CLASS
  METHOD
  PROPERTY
  FIELD
  CONSTRUCTOR
  ENUM
  INTERFACE
  FUNCTION
  VARIABLE
  CONSTANT
  STRING
  NUMBER
  BOOLEAN
  ARRAY
}

const symbolKindMap StringMap<VisualStudioCode.SymbolKind> = {
  "OBJECT_CLASS": .CLASS,
  "OBJECT_ENUM": .ENUM,
  "OBJECT_INTERFACE": .INTERFACE,
  "OBJECT_NAMESPACE": .NAMESPACE,
  "OBJECT_WRAPPED": .CLASS,

  "FUNCTION_ANNOTATION": .FUNCTION,
  "FUNCTION_CONSTRUCTOR": .CONSTRUCTOR,
  "FUNCTION_GLOBAL": .FUNCTION,
  "FUNCTION_INSTANCE": .METHOD,

  "VARIABLE_ENUM_OR_FLAGS": .VARIABLE,
  "VARIABLE_GLOBAL": .VARIABLE,
  "VARIABLE_INSTANCE": .FIELD,
}

def computeDocumentSymbols(skew dynamic, request dynamic) List<dynamic> {
  var result = skew.symbolsQuery({
    "source": request.uri,
  })
  if result.symbols == null {
    return null
  }
  var symbols List<dynamic> = []
  for symbol in result.symbols as List<dynamic> {
    var kind = symbolKindMap.get(symbol.kind, .NONE)
    if kind != .NONE {
      symbols.append({
        "name": symbol.name,
        "kind": kind,
        "location": {
          "uri": request.uri,
          "range": convertRangeFromServer(symbol.range),
        },
        "containerName": symbol.parent,
      } as dynamic)
    }
  }
  return symbols
}

def computeRenameEdits(skew dynamic, request dynamic) dynamic {
  var result = skew.renameQuery({
    "source": request.textDocument.uri,
    "line": request.position.line,
    "column": request.position.character,
  })
  if result.ranges == null {
    return null
  }
  var map StringMap<List<dynamic>> = {}
  for range in result.ranges as List<dynamic> {
    var uri = range.source
    var changes = map.get(uri, null)
    if changes == null {
      map[uri] = changes = []
    }
    changes.append({
      "range": convertRangeFromServer(range),
      "newText": request.newName,
    } as dynamic)
  }
  return {
    "changes": map,
  }
}

const typeNameMap = {
  "PARAMETER_FUNCTION": "typeParameterName",
  "PARAMETER_OBJECT": "typeParameterName",

  "OBJECT_CLASS": "className",
  "OBJECT_ENUM": "className",
  "OBJECT_FLAGS": "className",
  "OBJECT_GLOBAL": "className",
  "OBJECT_INTERFACE": "className",
  "OBJECT_NAMESPACE": "className",
  "OBJECT_WRAPPED": "className",

  "FUNCTION_ANNOTATION": "identifier",
  "FUNCTION_CONSTRUCTOR": "identifier",
  "FUNCTION_GLOBAL": "identifier",
  "FUNCTION_INSTANCE": "identifier",
  "FUNCTION_LOCAL": "identifier",

  "VARIABLE_ARGUMENT": "parameterName",
  "VARIABLE_ENUM_OR_FLAGS": "parameterName",
  "VARIABLE_GLOBAL": "parameterName",
  "VARIABLE_INSTANCE": "parameterName",
  "VARIABLE_LOCAL": "parameterName",
}

var completionCache List<dynamic> = []

def computeCompletions(skew dynamic, request dynamic, builder Builder) List<dynamic> {
  var result = skew.completionQuery({
    "source": request.uri,
    "line": request.position.line,
    "column": request.position.character,
    "target": "js",
    "inputs": gatherInputs(builder.workspaceRoot, builder.openDocuments),
  })

  completionCache = result.completions
  if result.range == null || completionCache == null {
    return null
  }

  var list List<dynamic> = []
  var range = convertRangeFromServer(result.range)

  for i in 0..completionCache.count {
    var symbol = completionCache[i]
    list.append({
      "label": symbol.name,
      "kind": typeNameMap.get(symbol.kind, "text"),
      "textEdit": {
        "range": range,
        "newText": symbol.name,
      },
      "data": i,
    } as dynamic)
  }

  return list
}

def computeCompletionDetails(skew dynamic, request dynamic, connection dynamic) dynamic {
  var index = request.data as int

  if completionCache != null && index >= 0 && index < completionCache.count {
    var symbol = completionCache[index]
    var comments string = null

    # Format comments into paragraphs for documentation
    if symbol.comments != null {
      var lines List<string> = symbol.comments.map(line => line.trim())
      var wasBlank = false
      comments = ""

      for line in lines {
        if line != "" {
          comments += wasBlank ? "\n\n" : " "
        }
        comments += line
        wasBlank = line == ""
      }
    }

    return {
      "detail": symbol.type,
      "documentation": comments,
    }
  }

  return null
}

class Builder {
  var skew dynamic
  var connection dynamic
  var workspaceRoot string = null
  var openDocuments dynamic = null
  var timeout = -1

  def buildLater {
    clearTimeout(timeout)
    timeout = setTimeout(=> {
      reportErrorsFromServer(connection, => {
        var diagnostics = build(self)
        sendDiagnostics(openDocuments, diagnostics, connection)
      })
    }, 100)
  }
}

def reportErrorsFromExtension(callback fn()) {
  try {
    callback()
  } catch e dynamic {
    var message = (e && e.stack ? e.stack : e) + ""
    dynamic.console.error("skew: \(message)")
    vscode.window.showErrorMessage("skew: \(message)")
  }
}

def reportErrorsFromServer(connection dynamic, callback fn()) {
  try {
    callback()
  } catch e dynamic {
    var message = (e && e.stack ? e.stack : e) + ""
    connection.console.error("skew: \(message)")
    connection.window.showErrorMessage("skew: \(message)")
  }
}

def findAllFiles(root string, filter fn(string) bool) List<string> {
  var files List<string> = []
  var folders = [root]

  while !folders.isEmpty {
    var folder = folders.takeLast
    var entries List<string> = fs.readdirSync(folder)

    for entry in entries {
      var absolute = path.join(folder, entry)

      if fs.statSync(absolute).isDirectory() {
        folders.append(absolute)
      }

      else if filter(entry) {
        files.append(absolute)
      }
    }
  }

  return files
}

def gatherInputs(workspaceRoot dynamic, openDocuments dynamic) List<dynamic> {
  var inputs List<dynamic> = []
  var openURIs StringMap<int> = {}

  # Always include all open documents
  for document in openDocuments.all() as List<dynamic> {
    openURIs[document.uri] = 0
    inputs.append({
      "name": document.uri,
      "contents": document.getText(),
    } as dynamic)
  }

  # Read file contents for all non-open files
  if workspaceRoot != null {
    for absolute in findAllFiles(workspaceRoot, name => name.endsWith(".sk")) {
      if !(pathToURI(absolute) in openURIs) {
        inputs.append({
          "name": pathToURI(absolute),
          "contents": fs.readFileSync(absolute, "utf8"),
        } as dynamic)
      }
    }
  }

  return inputs
}

def build(builder Builder) List<dynamic> {
  return builder.skew.compile({
    "target": "js",
    "inputs": gatherInputs(builder.workspaceRoot, builder.openDocuments),
    "stopAfterResolve": true,
  }).log.diagnostics
}

def convertRangeFromExtension(range dynamic) dynamic {
  # TextDocument.getText() crashes if the range uses duck typing
  return vscode.Range.new(
    range.start.line, range.start.column,
    range.end.line, range.end.column)
}

def convertRangeFromServer(range dynamic) dynamic {
  return {
    "start": {
      "line": range.start.line,
      "character": range.start.column
    },
    "end": {
      "line": range.end.line,
      "character": range.end.column
    },
  }
}

def sendDiagnostics(openDocuments dynamic, diagnostics List<dynamic>, connection dynamic) {
  var allDocuments List<dynamic> = openDocuments.all()
  var map StringMap<List<dynamic>> = {}

  for diagnostic in diagnostics {
    var absolute = diagnostic.range.source
    var group = map.get(absolute, null)

    if group == null {
      group = []
      map[absolute] = group
    }

    group.append({
      "severity": diagnostic.kind == "error" ? server.DiagnosticSeverity.Error : server.DiagnosticSeverity.Warning,
      "range": convertRangeFromServer(diagnostic.range),
      "message": diagnostic.text,

      # The only way to transport extra data is by abusing the "code" field
      "code": JSON.stringify(diagnostic.fixes),
    } as dynamic)
  }

  for document in allDocuments {
    connection.sendDiagnostics({
      "uri": document.uri,
      "diagnostics": map.get(document.uri, []),
    })
  }
}

def pathToURI(absolute string) string {
  return "file://" + "/".join(absolute
    .replaceAll("\\", "/").split("/")
    .map<string>(dynamic.encodeURIComponent))
}
